"use strict"

/**
 * File Name: intermediate.js
 * Description: This JavaScript file is meant to be read by intermediate.html .
 *              It shows the map and provides the various functionality on the page, including displaying user
 *              input data, enabling the use of navigation buttons (continue & previous page), validating input
 *              data, and storing the input data.
 *              
 *              The input data for this page includes the intermediate locations of the booking, which are
 *              optional.
*/


/**
 * This function is responsible for displaying the list of intermediate locations in newTrip on the page. This
 * required HTML is generated by looping over the array of objects for the intermediate locations and extracting
 * the name and address data stored inside. Furthermore, an icon with a callback of removeLocation containing the
 * index of each location is added to each list item. The final html is then assigned as the innerHTML of the
 * corresponding reference.
 * 
 * @returns {void}
 */

function displayInfoList() {
    const INTERMEDIATE = newTrip.intermediate;
    if (INTERMEDIATE.length === 0) {
        return;
    }

    let listHtml = `<ul class="demo-list-two mdl-list location-mdl-list">`
    listHtml += INTERMEDIATE.reduce(
        (finalHtml, { name, address }, index) => {
            return finalHtml + `
            <li class="mdl-list__item mdl-list__item--two-line">
                <!-- Name and Address-->
                <span class="mdl-list__item-primary-content">
                    ${index + 1}: ${name}
                    <span class="mdl-list__item-sub-title">${address}</span>
                </span>

                <!-- Remove Button -->
                <span class="mdl-list__item-secondary-action">
                    <button class="mdl-button mdl-js-button mdl-button--fab mdl-js-ripple-effect mdl-button--colored shrinked-mdl-button"
                        onclick="removeLocation(${index})">
                        <i class="material-icons">remove</i>
                    </button>
                </span>
            </li>`;
        }, "");

    listHtml += `</ul>`;
    listRef.innerHTML = listHtml;
}


/**
 * This function is responsible for displaying the map labels (markers and popups) for all intermediate locations
 * in newTrip. It first checks if there are any existing map labels and removes them from the map. Then, it 
 * creates and adds the corresponding markers and popups for each intermediate location in newTrip to the map
 * using the name, address and coordinates data. The reference for each map label is then saved in mapLabels to
 * be removed if the function is called again.
 * 
 * @returns {void}
 */
function displayMapLabels() {
    let allIntermediate = newTrip.intermediate;

    mapLabels.forEach(({ marker, popup }) => {
        marker.remove();
        popup.remove();
    })
    mapLabels = [];

    allIntermediate.forEach(({ coordinates, name, address }, index) => {
        let marker = new mapboxgl.Marker({
            color: "#FF8C00",
            draggable: true
        })
            .setLngLat(coordinates)
            .addTo(map)
            .on("dragend", () => {
                parseNewCoordinates([marker.getLngLat().lng, marker.getLngLat().lat], index);
                markerDragFlag = false;
            });

        marker.getElement().addEventListener("touchstart", () => {
            markerDragFlag = true;
        });

        let popup = new mapboxgl.Popup({
            offset: {
                'bottom': [0, -45],
                'top': [0, 10]
            }
        })
            .setHTML(`
                    <h6>${index + 1}: ${name}</h6>
                    <p>${address}</p>`
            );

        marker.setPopup(popup)
        marker.addTo(map);
        popup.addTo(map);

        mapLabels.push({
            marker: marker,
            popup: popup
        });
    })
}


/**
 * This function is responsible for displaying the path through all locations in newTrip on the map. First, it
 * checks if a path has been displayed on the map and removes it if it exists. Then, it retrives the geojson
 * object for the path to display from newTrip using getPathGeojson(). The layer to display the path is then
 * added to the map using the retrieved geojson as the source.
 * 
 * @returns {void}
 */
function displayPath() {
    if (pathGeojson !== null) {
        map.removeLayer("path");
        map.removeSource("path");
    }
    pathGeojson = newTrip.getPathGeojson();

    map.addLayer({
        id: 'path',
        type: 'line',
        source: pathGeojson,
        layout: {
            'line-join': 'round',
            'line-cap': 'round'
        },
        paint: {
            'line-color': 'rgba(175, 238, 238, 0.5)',
            'line-width': 6
        }
    });
}


/**
 * This function is responsible for removing the intermediate location of the specified index from newTrip. A
 * confirmation prompt is first displayed. Upon rejection, the function exits. Otherwise, the deleteIntermediate
 * method is called on newTrip with the passed index to remove it from newTrip. The details on the page is then
 * updated to reflect the new changes by calling displayInfoList, displayMapLabels and displayPath.
 * 
 * @param {number} index: Index of the location to remove
 * @returns 
 */
function removeLocation(index) {
    // confirmation
    if (!window.confirm("Remove this intermediate location?")) {
        return;
    }

    // update newTrip
    newTrip.deleteIntermediate(index);

    // update page
    displayInfoList();
    displayMapLabels();
    displayPath();
}


/**
 * This function is responsible for initiating the code to update the page with the provided geocoded data.
 * 
 * If the data is not valid (no results), the function will then check if editIndex has been specified. If it is
 * defined (this implies that an existed marker has been moved in an attempt to edit an input location), the 
 * oorresponding marker is moved back to its previous coordinates, which can be retrieved from newTrip using the
 * index. The global variable editIndex is also reset. Then, the function exits.
 * 
 * If all data is valid, the function checks if editIndex is defined. If it is, which corrsesponds to an attempt
 * to edit an input location, the editIntermediate method is called on newTrip with the new location object and 
 * specified index. The global variable editIndex is also reset. Otherwise, the addIntermediate function is
 * called. Finally, the page is updated to reflect the changes using displayInfoList, displayMapLabels and
 * displayPath.
 * 
 * @param {Object} data: Object containing the geocoded location data passed by OpenCage Geocoder API
 * @returns {void}
 */
function updatePageWithData(data) {
    let newLocationObject = {};

    if (data.results.length === 0) {
        window.alert("Invalid location input!");

        if (editIndex !== undefined) {
            // restore marker to previous location
            mapLabels[editIndex].marker.setLngLat(newTrip.intermediate[editIndex].coordinates);
            mapLabels[editIndex].popup.setHTML(`
                    <h6>${newTrip.intermediate[editIndex].name}</h6>
                    <p>${newTrip.intermediate[editIndex].address}</p>`
            );
        }

        editIndex = undefined;
        return;
    }

    let formattedString = data.results[0].formatted;
    let splitIndex = formattedString.indexOf(",");
    newLocationObject.name = formattedString.slice(0, splitIndex);
    newLocationObject.address = formattedString.slice(splitIndex + 1);
    newLocationObject.coordinates = [data.results[0].geometry.lng, data.results[0].geometry.lat];

    if (editIndex === undefined) {
        newTrip.addIntermediate(newLocationObject)
    }
    else {
        newTrip.editIntermediate(newLocationObject, editIndex);
        editIndex = undefined;
    }

    // update page
    displayInfoList();
    displayPath();
    displayMapLabels();
}


/**
 * This function is responsible for sending a web servide request to the OpenCage Geocoder API to apply reverse
 * geocoding to the provided coordinates and initiating the code to update the page with the provided data.
 * This is achieved by using the webServiceRequest function with the URL of the web service together with an
 * object containing the key-value pairs to be used in the query string, which includes the passed coordinates
 * and a JSONP callback to the updatePageWithGeocodedData function. The function global variables editIndex
 * (assign the value in the parameter index) is also mutated in preparation for the use in later function calls. 
 * 
 * @param {number[]} coordinates the coordinates to be sent to for geocoding 
 * @param {number|undefined} index the index of the intermediate location in newTrip to edit (leave unspecified
 *                                 if the coordinates is for a new location to add)
 */
function parseNewCoordinates(coordinates, index = undefined) {
    editIndex = index;
    const URL = "https://api.opencagedata.com/geocode/v1/json";
    const QUERY_OBJECT = {
        "q": `${coordinates[1]}+${coordinates[0]}`,
        "jsonp": "updatePageWithData",
        "key": openCageToken,
        "no_annotations": 1,
        "limit": 1,
        "countrycode": "MY"
    };
    webServiceRequest(URL, QUERY_OBJECT);
}


/**
 * This function is responsible for saving all the user input on the page into newBooking. This includes all the
 * intermediate locations, which is contained inside newTrip.
 * 
 * @returns {void}
 */
function saveData() {
    newBooking.trip = newTrip;
    localStorageUpdate(NEW_BOOKING_KEY, newBooking);
}



/* Global Code on load */
// used tokens
mapboxgl.accessToken = "pk.eyJ1IjoiamxpbTAxNTkiLCJhIjoiY2tud3E1NDF0MGR1cDJvcGJuanh4NGJqZiJ9.cz5fuPVq9Cz3GJ-oJwWFgw";
let openCageToken = "01de3ec0a3364b45bc19d278307c756a";

// global variables
let newTrip = newBooking.trip;
let mapLabels = [];
let pathGeojson = null;
let currentCoordinates = null;
let editIndex = null;
let markerDragFlag = false;

// page input element references
let currentLocationButton = document.getElementById("currentLocationButton");
let addButton = document.getElementById("addButton");
let continueButton = document.querySelector("#continueButtonDiv button");
let previousButton = document.getElementById("previousButton");

// page output element references
let addButtonTextRef = document.getElementById("addButtonText");
let listRef = document.querySelector(".scrolling-list-container");
let map = new mapboxgl.Map({
    container: 'map',
    center: newTrip.getCenter(),
    zoom: 8,
    style: 'mapbox://styles/mapbox/dark-v10'
});


//--- Page Initialization ---
displayInfoList();
map.on("load", () => {
    displayMapLabels();
    displayPath();

    // display static marker and popup for start and end
    const END_POINTS = [newTrip.start, newTrip.end];
    END_POINTS.forEach(({ coordinates, name, address }, index) => {
        const MARKER_COLORS = ["#98FB98", "#FF6347"];
        const LABEL = (index === 0) ? "Start" : "End";

        let popup = new mapboxgl.Popup({
            offset: {
                'bottom': [0, -45],
                'top': [0, 10]
            }
        })
            .setHTML(`
                    <h6>${LABEL}: ${name}</h6>
                    <p>${address}</p>`
            );

        new mapboxgl.Marker({
            color: MARKER_COLORS[index],
        })
            .setLngLat(coordinates)
            .setPopup(popup)
            .addTo(map);

        popup.addTo(map);
    });

    // zoom to appropriate level to see all markers
    let bounds = new mapboxgl.LngLatBounds();
    newTrip.allCoordinates.forEach((current) => {
        bounds.extend(current);
    })
    map.fitBounds(bounds, { padding: 150 });
});

// create current location marker
navigator.geolocation.getCurrentPosition(
    // success
    (pos) => {
        currentCoordinates = [pos.coords.longitude, pos.coords.latitude];

        // initialize current location point
        map.addSource('point', {
            'type': 'geojson',
            'data': {
                'type': 'FeatureCollection',
                'features': [{
                    'type': 'Feature',
                    'geometry': {
                        'type': 'Point',
                        'coordinates': currentCoordinates
                    }
                }]
            }
        });

        map.addLayer({
            'id': 'point',
            'type': 'circle',
            'source': 'point',
            'paint': {
                'circle-color': '#4264fb',
                'circle-stroke-color': 'white',
                'circle-radius': 12,
                'circle-stroke-width': 4
            }
        });
    },

    // failure
    (err) => {
        console.warn('ERROR(' + err.code + '): ' + err.message);
        window.alert("Unable to get current location! Enable location services and refresh to retry.");
    }
);


//--- Event Listeners ---
// set event listener for add button
addButton.addEventListener("click", () => {
    let addHandler = (e) => {
        parseNewCoordinates([e.lngLat.lng, e.lngLat.lat]);

        // reset and remove event listeners after input given
        currentLocationButton.disabled = true;
        addButton.disabled = false;
        addButtonTextRef.innerText = "Add Intermediate Location";
        map.off('click', addHandler);
        currentLocationButton.removeEventListener('click', currentLocationHandler);
    }

    let currentLocationHandler = () => {
        parseNewCoordinates(currentCoordinates);
        map.panTo(currentCoordinates);

        // reset and remove event listeners after input given
        currentLocationButton.disabled = true;
        addButton.disabled = false;
        addButtonTextRef.innerText = "Add Intermediate Location";
        map.off('click', addHandler);
        currentLocationButton.removeEventListener('click', currentLocationHandler);
    }

    // enable current location button and map tap input
    if (currentCoordinates !== null) {
        currentLocationButton.disabled = false;
        currentLocationButton.addEventListener("click", currentLocationHandler);
    }
    map.on('click', addHandler);
    addButton.disabled = true;
    addButtonTextRef.innerText = "Tap on map to add location.";
});

// set event listener for continue button
continueButton.addEventListener("click", () => {
    saveData();
    window.location = "taxi.html";
});

// set event listener for previous button
previousButton.addEventListener("click", () => {
    saveData();
    window.location = "index.html";
});

// constantly update current location coordinates
let watchHandler = navigator.geolocation.watchPosition(
    (pos) => {
        currentCoordinates = [pos.coords.longitude, pos.coords.latitude];

        // update current location marker
        map.getSource("point").setData({
            'type': 'FeatureCollection',
            'features': [
                {
                    'type': 'Feature',
                    'geometry': {
                        'type': 'Point',
                        'coordinates': currentCoordinates
                    }
                }
            ]
        });
    }
)

// change current location marker by dragging
map.on('touchstart', 'point', (e) => {
    // don't drag together with other location markers
    if(markerDragFlag) {
        return;
    }

    // prevent map from panning
    e.preventDefault();

    // stop watchPosition from working once marker is adjusted
    navigator.geolocation.clearWatch(watchHandler);

    // function handle for changing marker as it is dragged
    let draggingPoint = (e) => {
        currentCoordinates = [e.lngLat.lng, e.lngLat.lat];
        map.getSource('point').setData({
            'type': 'FeatureCollection',
            'features': [
                {
                    'type': 'Feature',
                    'geometry': {
                        'type': 'Point',
                        'coordinates': currentCoordinates
                    }
                }
            ]
        });
    }

    map.on('touchmove', draggingPoint);

    map.once('touchend', () => {
        map.off("touchmove", draggingPoint);
    });
});